1.agent 探针及其实现原理
2.mysql的隔离级别
     --未提交读                  （脏读，不可重复读，幻读）
     --已提交读                  （不可重复读，幻读）
     --可重复读（mysql默认隔离级别 （幻读）
     --串行读

 脏读：事物A读到了事物B未提交的数据，然后事物B回滚了，事物A两次读到了不一样的数据 --> 一个事物读到了另一个事物未提交的数据即是脏读

 不可重复读：事物A在某个条件下查询出10条数据，事物没有提交，此时事物B在相同的条件下插入一条数据并提交事物,事物A再次会查询会出现11条数据
           事物A在某个条件下查询出10条数据，事物没有提交,此时事物B在相同的条件下更新一条数据并提交事物,事物A再次查询会发现少了一条数据
           -->不可重复读针对的是数据的更新

 幻读：事物A在某个条件下查询出10条数据，事物没有提交，此时事物B在相同的条件下插入一条数据并提交事物，接下来在当前条件下事物A进行更新，
      此时事物A会产生幻读，更新11条数据 --> 幻读是针对于数据的插入操作

3.mvcc的实现机制 快照存在哪

4.内部类与静态内部类的 区别 匿名函数能不能用外部类的属性
5.tomcat的加载机制 是否可以反着来 父类的ClassLoader是否可以加载子类的class文件

6.volatile到底咋用
答：
   原理：
     -- 当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
     -- 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，
        这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；
       （什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）
   实践：一个类的全局变量i，这个类的一个方法做i++操作，5000个线程并发执行这个方法，最后得到的结果，不一定为5000
   原因：i++不是一个原子操作，首先他需要将值从i从主存中读取出来，然后对i进行加一操作，两个线程读取的i值是一样的，都是当前主存中的数据
        但是两个线程同时将此时的i值缓存在cup中，线程一对i进行加一得到1（假如此时主存中的为0），线程2同时也对当前i值进行加一，理想情况
        两个线程执行当前方法，此时i应该为2,但是得到的结果却为1。
   解决方法：改int类型的变量应使用Atomic类型定义，保证其原子性,利用其cas算法

6.threadLocal如何实现的 怎么保证线程隔离的