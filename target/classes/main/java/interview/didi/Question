1.bean的三级缓存

singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
singletonFactories：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖

先从一级缓存singletonObjects中去获取。（如果获取到就直接return）
如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存earlySingletonObjects中获取。（如果获取到就直接return）
如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。
（如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动（是剪切、不是复制哦~）到了二级缓存）
 加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决


 依旧以上面A、B类使用属性field注入循环依赖的例子为例，对整个流程做文字步骤总结如下：

 1.使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~
 2.实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
 3.初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
 4.为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~
 5.实例化B，并将其放入缓存。（此时B也能够被引用了）
 6.初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
 7.此处重要：初始化B时会调用getBean(A)去容器内找到A，
   上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回
 8.B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。
 9.因为B实例已经成功返回了，因此最终A也初始化成功
 10.到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~



getSingleton()从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：就在于singletonFactories这个三级缓存。这个Cache里面都是ObjectFactory，它是解决问题的关键


2.跳表如何实现
跳跃列表是一种数据结构。它允许快速查询一个有序连续元素的数据链表
而其快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。
一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。
这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见

3.重量级锁与ReentrantLock的区别，锁变化的过程 共享锁与独占锁的实现，重量级锁为什么自璇

自旋锁
首先，内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。
如果锁的粒度小，那么锁的持有时间比较短（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。
那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。

当前线程竞争锁失败时，打算阻塞自己
不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会
在自旋的同时重新竞争锁
如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己


4.eruak挂掉一个服务如何保证安全，如何摘掉挂掉的服务
Eureka Server中有一个EvictionTask，用于检查服务是否失效。Eviction（失效服务剔除）用来定期（默认为每60秒）在Eureka Server检测失效的服务，
检测标准就是超过一定时间没有Renew的服务。默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。
失效时间可以通过eureka.instance.leaseExpirationDurationInSeconds进行配置，定期扫描时间可以通过eureka.server.evictionIntervalTimerInMs进行配置。

服务剔除#evict方法中有很多限制，都是为了保证Eureka Server的可用性：
比如自我保护时期不能进行服务剔除操作、过期操作是分批进行、服务剔除是随机逐个剔除，剔除均匀分布在所有应用中，
防止在同一时间内同一服务集群中的服务全部过期被剔除，以致大量剔除发生时，在未进行自我保护前促使了程序的崩溃。

5.hashmap优化了哪些点 为什么初始值为2的倍数
6.线程池的设计，如何选择最大线程数，工作队列，为什么用threadPoolExcetor(阿里巴巴开发手册)
7. a ,b,c 组合索引 ab的查询过程 和 ac的查询过程 最佳做前缀原则
8.sping什么时候事物会失效，一个service 里 A方法 调用B方法如何失效
9.分布式锁的实现，选择那种实现 redLock 效率
10.如何通过反射拿到类中的私有属性
11.如何判断是同一个对象，同一个实例