1.mysql如何实现可重复读
答：
     (1)可重复读是指：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
        我们可以简单理解为：在可重复读隔离级别下，事务在启动的时候就”拍了个快照“。注意，这个快照是基于整个库的。
    （2）InnoDB 里面每个事务都有一个唯一的事务 ID，叫作 transaction id。
        它在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
        每条记录在更新的时候都会同时记录一条 undo log，这条 log 就会记录上当前事务的 transaction id，记为 row trx_id。
        记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
    （3）在可重复读隔离级别下，一个事务在启动时，InnoDB 会为事务构造一个数组，用来保存这个事务启动瞬间，当前正在”活跃“的所有事务ID。”活跃“指的是，启动了但还没提交。
   ***** InnoDB 就是利用 undo log 和 trx_id 的配合，实现了事务启动瞬间”秒级创建快照“的能力。

   InnoDB在更新时运用一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读“ （current read）。

   小结
   InnoDB 的行数据有多个版本，每个版本都有 row trx_id。
   事务根据 undo log 和 trx_id 构建出满足当前隔离级别的一致性视图。
   可重复读的核心是一致性读，而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用，就需要进入锁等待。

2.rocketMq如何实现分布式事物
 https://www.cnblogs.com/qdhxhz/p/11191399.html

 1、A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。

 2、当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。

 3、执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应)

 4.1)、如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。

 4.2)、如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。

 4.3)、如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。

3.如何实现分布式事物
4.线程池如何实现 用了哪些设计模式
    生产消费  模板方法
5.线程池的阻塞队列有哪些，特点是什么
6.volatile关键词的实现原理，用在哪里，为什么这样用
7.redis大key的初始化过程，为什么会打爆cup，如何优化
8.消息堆积怎么处理
9.线程池内部抛异常怎么办，如何保证任务不丢，线程池中的线程变化过程
10.如何给线程重命名
11.rocketMq的broker分片过程
12.你项目中分布式的实现原理，redLock的实现原理
13.ThreadLocal咋回事
14.cpu密集型应用都哪些优化的解决方案