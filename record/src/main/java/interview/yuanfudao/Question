1.redis持久化
（1）rdb怎么去做的aof怎么用？
    * RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。

    * 在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。

    * Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；

（2）主从模式怎么使用这两种方式  主节点挂掉Redis持久化的方式如何选择，保证数据不丢失？（主备切换的过程，可能会导致数据丢失）
     * 如果采用了主从架构，那么建议必须开启master node的持久化，防止在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了

     原因：
     1.异步复制导致的数据丢失:
      因为master -> slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了

     2.脑裂导致的数据丢失
      脑裂，也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着
      此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master,这个时候，集群里就会有两个master，也就是所谓的脑裂
      此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了
      因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据

     解决方案：
     1.解决异步复制和脑裂导致的数据丢失
       redis.conf 中
       min-slaves-to-write 1 430行
       min-slaves-max-lag 10 431行
       要求至少有1个slave，数据复制和同步的延迟不能超过10秒
       如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了
       上面两个配置可以减少异步复制和脑裂导致的数据丢失

      （1）减少异步复制的数据丢失
       有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，
       这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内

      （2）减少脑裂的数据丢失
       如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求
       这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失
       上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求
       因此在脑裂场景下，最多就丢失10秒的数据

2.mysql --> B+树
 (1)B+树有什么优点
 (2)为什么不用多路tree?
3.隔离级别
(1)能解释一下幻读吗 会少吗
(2)不可重复读  是什么
(3)和幻读的区别是什么
4.RocketMq的广播模式和集群模式有什么区别

5.Rocket如何保证顺序消费
+------------------------------------------------------------------+
+------------------------------------------------------------------+
消费模型就是单 consumer 实例 + 多 worker 线程模型
RocketMQ 会为每个队列分配一个 PullRequest，并将其放入 pullRequestQueue，
PullMessageService 线程会不断轮询从 pullRequestQueue 中取出 PullRequest 去拉取消息，接着将拉取到的消息给到 ConsumeMessageService 处理，ConsumeMessageService 有两个子接口：
ConsumeMessageConcurrentlyService
ConsumeMessageOrderlyService
+------------------------------------------------------------------+
+------------------------------------------------------------------+

ConsumeMessageConcurrentlyService 内部有一个线程池，用于并发消费，同样地，
如果需要顺序消费，那么 RocketMQ 提供了 ConsumeMessageOrderlyService 类进行顺序消息消费处理。

1）RocketMQ 会为每个消息队列建一个对象锁，这样只要线程池中有该消息队列在处理，则需等待处理完才能进行下一次消费，保证在当前 Consumer 内，同一队列的消息进行串行消费。

2）向 Broker 端请求锁定当前顺序消费的队列，防止在消费过程中被分配给其它消费者处理从而打乱消费顺序。



6.Rocket每个节点会存放全量数据吗，如何分到不同的broker
7.sct    netty  多路复用有了解过吗    eventloop  channel  注册时间
8.io多路复用的好处
9.Redis为什么不使用多线程
10.Redis的编码格式有哪些
11.SDS如何保证二进制安全的
